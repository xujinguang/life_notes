## HTTP优化

TCP面向连接，建立连接和断开连接都不需要耗费时间和资源。优化的重点方向有两个：低延迟，高带宽。

1. 预创建思路：先创建好一批连接，然后请求来了直接拿一个，用完还回去了——这就是连接池。
2. 每次都经历完成TCP连接过程，能不能建立完之后不断开，一直使用——这就是长连接。
3. HTTPS在TCP之上还有一层SSL。那么每次加解密更加费时，能不能一次加密后复用——这就是会话复用。
4. TCP的三次握手，挥手太麻烦了，能不能简化——这就是HTTP2的QUICK协议和HTTP3的基于UDP协议。

<img src="https://images2015.cnblogs.com/blog/801753/201705/801753-20170530165016352-2127690583.jpg" style="zoom:80%;" />

### 1. 连接池

#### 1.1 



### 2. 长连接

#### 2.1 背景

HTTP1.0 默认使用短连接——每次请求都需要建立一个单独的连接来传输数据，传输完成后断开连接。 管理起来比较简单，存在的连接都是有用的连接。 

在纯文本页面的互联网时代，这个问题不是很大，一个页面只是一个静态页面，也没多少js和图片文件，基本上几个连接就搞定了。但是随着多媒体的发展，web页面变得越来越华丽的，越来越丰富多彩。增加视觉冲击，满足感觉体验，当然要付出代价的，那就是资源的开销大幅度提高。一个页面上太多的资源需要从服务端获取，如果每个资源获取都使用短连接，那么页面打开速度是十分缓慢的。

所以短连接对于多数据传输是耗时并且浪费流量的，因此长连接应运而生。

在HTTP1.1给出了改进，默认改为长连接。 **在同一个TCP连接上传送多个HTTP请求和响应，减少了建立和关闭连接的消耗延迟** 。因为，HTTP是上层应用层协议，TCP是下层运输层协议，上层复用下层是可以做到的。

#### 2.2 长连接原理

 长连接的HTTP协议header新增

```html
Connection:keep-alive|close
Keep-Alive: timeout=5, max=1000
```

如果服务端不识别keep-alive，则无法使用长连接。参数：[Connection](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection)， [Keep-Alive](https://tools.ietf.org/html/draft-thomson-hybi-http-timeout-03#section-2)

分为以下几个步骤：

- 客户端发送一个Connection: keep-alive的header，表示需要保持连接
- 客户端可以顺带Keep-Alive: timeout=5,max=100这个header给服务端，表示tcp连接最多保持5秒，长连接接受100次请求就断开，不过浏览器看了一些请求貌似没看到带这个参数的
- 服务端必须能识别Connection: keep-alive这个header，并且通过Response Header带同样的Connection: keep-alive，告诉客户端我可以保持连接
- 客户端和服务端之间通过保持的通道收发数据
- 最后一次请求数据，客户端带Connection：close这个header，表示连接关闭

#### 2.3 KeepAlive

- HTTP 协议的 KeepAlive 意图在于连接复用，同一个连接上串行方式传递请求 - 响应数据
- TCP 的 KeepAlive 机制意图在于保活、心跳，检测连接错误。
  -  ETIMEOUT 超时错误
  -  EHOSTUNREACH  主机不可达
  - reset

#### 2.4 要点

长连接不是永久保持连接，它有一个保持时间 ，用户可配置。如果是永久连接会有什么问题呢？

首先套接字也是文件。服务端能打开的文件个数是有限，如果所有连接都是永久的，套接字很快就耗尽，从而无法提供服务。这就类似拒绝服务攻击了。

其次，永久连接不意味着一直在使用。大部分都闲置的话，是资源浪费。所以对于高并发量的web站点，还是优选短连接，长连接反而是一种浪费。

### 3. 会话复用

- **session id**会话复用----对于已建立的TLS会话，使用session id为key（来自第一次请求的Server Hello中的session id），主密钥为value组成一对键值对保存在服务端和客户端的本地。当第二次握手时，客户端如果想复用会话，则发起的Client Hello中带上session id，服务端收到这个session id检查本地是否存在，有则允许会话复用，进行后续操作
- **session ticket**会话复用----一个session ticket是一个加密的数据blob，其中包含需要重用的TLS连接信息如session key等，它一般使用ticket key加密，因为ticket key服务端也知道，在初始化握手中服务端发送一个session ticket到客户端并存储到客户端本地，当会话重用时，客户端发送session ticket到服务端，服务端解密成功即可复用会话

 session id的方式缺点是比较明显的，主要原因是负载均衡中，多机之间不同步session，如果两次请求不落在同一台机器上就无法找到匹配信息，另外服务端存储大量的session id又需要消耗很多资源，而session ticket是比较好解决这个问题 

### 4. HTTP2/3

**多路复用 (Multiplexing)**

多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。

**二进制分帧**

HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。

HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。在过去， HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我调谐，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

这种单连接多资源的方式，减少服务端的链接压力,内存占用更少,连接吞吐量更大；而且由于 TCP 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少,使拥塞和丢包恢复速度更快。


**首部压缩（Header Compression）**

HTTP/1.1并不支持 HTTP 首部压缩，为此 SPDY 和 HTTP/2 应运而生， SPDY 使用的是通用的DEFLATE 算法，而 HTTP/2 则使用了专门为首部压缩而设计的 HPACK 算法。


**服务端推送（Server Push）**

服务端推送是一种在客户端请求之前发送数据的机制。在 HTTP/2 中，服务器可以对客户端的一个请求发送多个响应。Server Push 让 HTTP1.x 时代使用内嵌资源的优化手段变得没有意义；如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。这相当于在一个 HTML 文档内集合了所有的资源，不过与之相比，服务器推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。

### 5. CDN/缓存



### 参考文献

【1】[gRPC服务发现&负载均衡](https://segmentfault.com/a/1190000008672912)

