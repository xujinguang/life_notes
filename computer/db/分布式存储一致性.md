## 分布式存储一致性探究

一致性分为三类：强一致性，弱一致性和最终一致性。无论三种中那一种，它有个前提条件就是，它针对的是副本之间数据一致性而言的。为什么会有多个副本呢？因为副本是自然界容灾设计的唯一方式（想想我们的DNA副本和遗传，书本的印刷和个人照片的备份等等，都是采用这种策略）。

### 一、强一致性

读操作总是能读到之前写完成的操作结果。

由著名的CAP理论得知，分区可容忍性总是要满足，那么剩余的一致性和可用性无法同时满足。为何无法同时满足呢？采用强一致性，当网络或其他故障时，由于副本之间不通，那么写操作必须阻塞。如果写停止了，也就是系统失去可用性。反之，如果允许写继续满足系统的可用性，那么导致写的副本和其他副本数据不一致而违反了强一致性。

所以，要根据具体的业务场景而定一致性和可用性的折中点。比如金融业务，保证数据一致性，那么就需要停止写。对于允许一定程度数据丢失的的系统，在数据弱一致性情况下继续读写。

### 二、一致性协议

一致性协议由**拜占庭将军问题**引出的发明的，也是解决分布式存储当中数据一致性问题必备的。目前去中心化的区块链技术本质也是一致性协议。

一致性协议有多种分类，按照协调者的个数，可以分为单主和多主协议。单主是指只有一个协调者，比如2PC，Paxos，Raft，多主比如Pow协议和Gossip协议。

#### 2.0 2PC

2PC -- Two-phase Commit 两阶段提交协议。主要用于保证多个节点操作的原子性。

系统中包括一个协调者，多个事务参与者。

此协议假设每个节点都会记录操作日志并持久化到非易失存储介质，即使节点故障日志也不会丢失。

它包括两个阶段：1-请求阶段；2-提交阶段。

请求阶段协调者通知事务参与者准备提交或者取消事务，进入表决过程。参与者告诉协调者决定：同意或者取消（本地执行成功或失败）；提交阶段则是协调者将第一阶段投票结果进行决策：提交或者取消。当且仅当所有参与者同意提交事务协调者才能提交，否则取消事务。

存在的问题：

1. 参与者如果不及时表决，则协调者和其他参与者则进入无限等待中，等待意味着资源占有无法释放；
2. 协调者在第二阶段故障，导致参与者事务不知道回滚还是提交而阻塞。
3. 两阶段提交是阻塞协议。

解决办法：

1. 为参与者设置一个超时时间，如果超时没有表决，则整个事务取消。
2. 协调者故障时，需要落地日志并同步给备份协调者。需要借助外力。



#### 2.1 Paxos

Paxos将节点进程分成"发起者""接收者""学习者"三类。P - proposer;A - Acceptor；L-learners

发起者——发起新的更新称为提议。提议包括一个数字和提议内容。可以有多个发起者发起多个提议。因此，要求接收者可以同时接受多个提议。

接收者 —— 收到提议后可以接受（accept）提议，或者不接受。以及返回已经接受的提议。

学习者 —— 只能学习批准的提议。

过程如下：

```json
prepare阶段：
	1.proposer选择一个提案编号n并将prepare请求发送给acceptors中的一个多数派；
	2.acceptor收到prepare消息后，如果提案的编号大于它已经回复的所有prepare消息(回复消息表示接受accept)，则acceptor将自己上次接受的提案回复给proposer，并承诺不再回复小于n的提案；
批准阶段：
	1. 当一个proposer收到了多数acceptors对prepare的回复后，就进入批准阶段。它要向回复prepare请求的acceptors发送accept请求，包括编号n和根据P2c决定的value（如果根据P2c没有已经接受的value，那么它可以自由决定value）。
	2.在不违背自己向其他proposer的承诺的前提下，acceptor收到accept请求后即批准这个请求。
决议发布：
	发送给所有acceptor，提议生效。learner学习提议。
```

1. 需要一个递增的编号生成器；
2. 多数派由p自己选择，因此需要知道总数和选择的多数派。也可以每次发送全员。
3. A要记录自己已经接受的提议编号和提议内容；新的提议过来时候，需要比对编号；
4. 数据包区分每个阶段。因为接受者是被动选择，只能通过数据包类型告知这个提议在什么阶段。
5. 超过半数的回应都是空时才能提交自己的提议，否则提交回应中多数回应中编号最大的提议
6. 把提议换成更新的值更好理解。
7. 如果有提议进行中，则不能发现新的提议。
8. 

> 算法又被称为希腊城邦算法。Lamport虚拟了一个叫做Paxos的[希腊城邦](https://zh.wikipedia.org/wiki/希臘城邦)，这个岛按照议会民主制的政治模式制订法律，但是没有人愿意将自己的全部时间和精力放在这种事情上。所以无论是议员，议长或者传递纸条的服务员都不能承诺别人需要时一定会出现，也无法承诺批准决议或者传递消息的时间。只要等待足够的时间，消息就会被传到。另外，Paxos岛上的议员是不会反对其他议员提出的决议的。
>
> Paxos城中的一些位高权重的人们("发起者")会提出新的"法案"，这些法案需要立法委员("接收者")达成一致即多数同意才能通过。于是权贵们会预先给立法委员一些金钱，让他们通过自己的法案，这对应的就是"预请求"。
>
> 如果立法委员已经收到过更高贿赂的"预请求"，他们会拒绝，否则会同意。权贵们贿赂成功后，会告诉立法委员新的法案，在收到新法案之前，如果立法委员没有收到更高的贿赂，他们会选择接受这个法案，否则会拒绝。很关键的一点是如果立法委员在接收到更高的贿赂时已经接受了某个法案，那他在拒绝的同时，会告诉贿赂的权贵这个法案的内容。权贵会将自己发起的法案改成该法案的内容。

#### 决议的发布

一个显而易见的方法是当acceptors批准一个value时，将这个消息发送给所有learners。但是这个方法会导致消息量过大。

由于假设没有Byzantine failures，learners可以通过别的learners获取已经通过的决议。因此acceptors只需将批准的消息发送给指定的某一个learner，其他learners向它询问已经通过的决议。这个方法降低了消息量，但是指定learner失效将引起系统失效。

因此acceptors需要将accept消息发送给learners的一个子集，然后由这些learners去通知所有learners。

但是由于消息传递的不确定性，可能会没有任何learner获得了决议批准的消息。当learners需要了解决议通过情况时，可以让一个proposer重新进行一次提案。注意一个learner可能兼任proposer。

#### Progress的保证

根据上述过程当一个proposer发现存在编号更大的提案时将终止提案。这意味着提出一个编号更大的提案会终止之前的提案过程。如果两个proposer在这种情况下都转而提出一个编号更大的提案，就可能陷入活锁，违背了Progress的要求。一般活锁可以通过 **随机睡眠-重试** 的方法解决。这种情况下的解决方案是选举出一个leader，仅允许leader提出提案。但是由于消息传递的不确定性，可能有多个proposer自认为自己已经成为leader。

缺点：

1. 不容易构建实践的系统
2. 理论不好理解
3. 单决策没有实用价值

#### 2.2 Raft

状态所有服务器上持久存在的

currentTerm服务器最后一次知道的任期号（初始化为 0，持续递增）

votedFor在当前获得选票的候选人的 Id

log[]日志条目集；每一个条目包含一个用户状态机执行的指令，和收到时的任期号

#### 2.3 Gossip

#### 2.4 Pow

